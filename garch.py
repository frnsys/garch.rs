import random
import numpy as np
from scipy import optimize

def garch_recursion(omega, alpha, beta, eps):
    m = np.mean(eps)
    init_sigma_2 = np.sum((eps-m)**2/(len(eps) - 1))

    sigma_2 = []
    for i in range(len(eps)):
        if i < len(alpha) or i < len(beta):
            sigma_2.append(init_sigma_2)
        else:
            next = predict_next(omega, alpha, beta, eps[:i], sigma_2[:i]);
            sigma_2.append(next);
    return sigma_2

def predict_next(omega, alpha, beta, eps, sigma_2):
    residual_term = sum(a * eps[-(i+1)]**2 for i, a in enumerate(alpha))
    volatility_term = sum(b * sigma_2[-(i+1)] for i, b in enumerate(beta))
    return omega + residual_term + volatility_term

def neg_loglikelihood(sigma_2, eps):
    loglik = np.sum(-np.log(sigma_2) - eps**2/sigma_2)
    return -loglik

def objective(coef, eps):
    # Assuming GARCH(2,2)
    sigma_2 = garch_recursion(coef[0], coef[1:3], coef[3:], eps)
    return neg_loglikelihood(sigma_2, eps)

if __name__ == '__main__':
    coef = [random.random() for _ in range(5)]
    print('Initial Coefficients:', coef)

    eps = np.array([-1.1654701930316889, -0.3221777990743186, -0.2431499478189077, 2.8125422250859105, 0.1341928615015077, -0.7569703736370905, 0.08841545075632712, 0.2798420570728233, 0.4816998443585289, 3.158372696656984, 0.37318270001112963, 1.7743499250446706, -1.861004409851564, -0.35689842526585536, -1.7696944629104723, -0.5564496214488425, -3.3539383014763833, 2.9268646559090294, -0.13491903842951225, -1.7348124824175055, 2.2178418295703786, 3.592051465142206, 2.1410361501538024, 0.8614541227741674, -1.1392795053372193, 4.255382942764708, 0.1769963368658432, -0.2335693737970976, 0.8547410204381866, 3.199456696764284, -0.23995621732425473, 0.3099132128650999, 0.5871442152070896, -0.27517482451072606, 0.9461684251163058, 1.7796414077513958, -0.9524338390523608, -0.9966715257560104, -2.012694356204234, 2.601871760001294, -0.780091356585498, 2.710712302971402, 3.81310277751141, 2.4878549702419295, -3.076583779450503, 3.2489317056902665, 1.1542779800633893, 0.26005743439510565, 0.06588694173039909, -1.9466744718584195, 0.628494440117738, 1.0068665560611494, 2.567740383116616, 4.801005828469198, 2.318213525267672, 4.045542810861785, -2.0381210401150063, -1.1168725947770337, 4.719460750425471, -3.2022041991087815, 2.2444355344207163, 1.6850039924229918, 0.13161600433891682, 1.1046237864655302, 2.4751428252408907, -2.408282749055503, -1.5359024355978137, -0.5485139129082867, -1.237331449458256, 0.6945848582098528, 0.9938919106018818, 0.6179091739368131, -0.381549873158788, -1.4473601590889258, -2.3939528324039836, 1.8356939610604008, 1.9635096411471158, 1.939795533832023, 2.9325856078879906, 1.9045915738937345, 0.22693650084324168, 1.7157903359755289, 1.627511528854953, 0.9653893579468947, 0.9922766834267972, -0.6772304328505118, -0.8693426459978123, -1.092201939721015, -0.671901560333212, 3.245055530954511, 1.7714465862352498, -0.47952624118428017, 2.3723225613786454, 0.09435239128509, -1.4676591596550348, -0.4263341894106554, 0.8518843594793817, 0.8920381698132289, 1.1680675214997935, 0.7180853111145963, -0.04009741833835763, 1.2279324984189874])

    bounds = [(1e-4, None) for _ in coef]
    res = optimize.minimize(objective, coef,
            args=(eps,),
            bounds=bounds,
            method='L-BFGS-B',
            # options={'disp': True},
        )

    print('Done')
    if not res.success:
        print('Failed:')
        print(res)
    else:
        print(res.x)